/* Auto-generated by genmsg_cpp for file /home/tscott/ros/wombot/wombot_msgs/msg/WombotVehicle.msg */
#ifndef WOMBOT_MSGS_MESSAGE_WOMBOTVEHICLE_H
#define WOMBOT_MSGS_MESSAGE_WOMBOTVEHICLE_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace wombot_msgs
{
template <class ContainerAllocator>
struct WombotVehicle_ {
  typedef WombotVehicle_<ContainerAllocator> Type;

  WombotVehicle_()
  {
  }

  WombotVehicle_(const ContainerAllocator& _alloc)
  {
  }

  static const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  frame_id;
  static const float length;
  static const float width;
  static const float height;
  static const float halflength;
  static const float halfwidth;
  static const float halfheight;
  static const float wheelbase;
  static const float front_bumper_px;
  static const float rear_bumper_px;
  static const float front_left_wheel_px;
  static const float front_left_wheel_py;
  static const float front_right_wheel_px;
  static const float front_right_wheel_py;
  static const float rear_left_wheel_px;
  static const float rear_left_wheel_py;
  static const float rear_right_wheel_px;
  static const float rear_right_wheel_py;
  static const float geom_px;
  static const float geom_py;
  static const float geom_pa;
  static const float max_steer_degrees;
  static const float max_steer_radians;
  static const float turn_radius;
  static const float front_outer_wheel_turn_radius;
  static const float front_inner_wheel_turn_radius;
  static const float rear_outer_wheel_turn_radius;
  static const float rear_inner_wheel_turn_radius;

private:
  static const char* __s_getDataType_() { return "wombot_msgs/WombotVehicle"; }
public:
  ROS_DEPRECATED static const std::string __s_getDataType() { return __s_getDataType_(); }

  ROS_DEPRECATED const std::string __getDataType() const { return __s_getDataType_(); }

private:
  static const char* __s_getMD5Sum_() { return "c20c5cfb6e2f3e9f2e675c3f745ad041"; }
public:
  ROS_DEPRECATED static const std::string __s_getMD5Sum() { return __s_getMD5Sum_(); }

  ROS_DEPRECATED const std::string __getMD5Sum() const { return __s_getMD5Sum_(); }

private:
  static const char* __s_getMessageDefinition_() { return "#  ART vehicle dimensions.\n\
#  $Id: ArtVehicle.msg 1161 2011-03-26 02:10:49Z jack.oquin $\n\
\n\
#  This class encapsulates constants for the dimensions of the ART\n\
#  autonomous vehicle.  All units are meters or radians, except where\n\
#  noted.  This is not a published message, it defines multi-language\n\
#  constants.\n\
\n\
# ROS frame ID\n\
string frame_id = \"vehicle\"\n\
\n\
float32 length = 0.55                   # overall length\n\
float32 width = 0.44                    # overall width\n\
float32 height = 0.3                    # overall height (TBD)\n\
float32 halflength = 0.275                # length / 2\n\
float32 halfwidth = 0.22                # width / 2\n\
float32 halfheight = 0.15               # height / 2\n\
float32 wheelbase = 0.41     	# wheelbase\n\
\n\
# egocentric coordinates relative to vehicle origin at center of\n\
# rear axle\n\
float32 front_bumper_px = 0.47   	# (approximately)\n\
float32 rear_bumper_px = -0.08           # front_bumper_px - length\n\
float32 front_left_wheel_px = 0.41   # wheelbase\n\
float32 front_left_wheel_py = 0.22       # halfwidth\n\
float32 front_right_wheel_px = 0.41  # wheelbase\n\
float32 front_right_wheel_py = -0.22    #-halfwidth\n\
float32 rear_left_wheel_px = 0.0\n\
float32 rear_left_wheel_py = 0.22       # halfwidth\n\
float32 rear_right_wheel_px = 0.0\n\
float32 rear_right_wheel_py = -0.22     #-halfwidth\n\
\n\
# Player geometry, egocentric pose of robot base (the px really\n\
# does need to be positive for some reason)\n\
float32 geom_px = 0.195                   # front_bumper_px - halflength\n\
float32 geom_py = 0.0\n\
float32 geom_pa = 0.0\n\
\n\
#float32 velodyne_px = 0.393             # (approximately)\n\
#float32 velodyne_py = 0.278             # (approximately)\n\
#float32 velodyne_pz = 2.4               # (calibrated)\n\
#float32 velodyne_yaw=-0.0343           # (before remounting)\n\
#float32 velodyne_yaw=-0.02155           # (approximately)\n\
#float32 velodyne_pitch=0.016353735091186868 # (calculated)\n\
#float32 velodyne_roll=0.0062133721370998124 # (calculated)\n\
\n\
#float32 front_SICK_px = 3.178\n\
#float32 front_SICK_py= 0.0		# (approximately)\n\
#float32 front_SICK_pz = 0.941\n\
#float32 front_SICK_roll = 0.0		# (approximately)\n\
#float32 front_SICK_pitch = 0.0		# (approximately)\n\
#float32 front_SICK_yaw = 0.027	        # (approximately)\n\
\n\
#float32 rear_SICK_px = -1.140\n\
#float32 rear_SICK_py = 0.0              # (approximately)\n\
#float32 rear_SICK_pz = 0.943\n\
#float32 rear_SICK_roll = 0.0		# (approximately)\n\
#float32 rear_SICK_pitch = 0.0		# (approximately)\n\
#float32 rear_SICK_yaw = 3.1415926535897931160  # (approximately PI)\n\
\n\
#float32 right_front_camera_px = 0.52    # velodyne_px+0.127 (approx)\n\
#float32 right_front_camera_py = 0.189   # velodyne_py-0.089 (approx)\n\
#float32 right_front_camera_pz = 2.184   # velodyne_pz-0.216 (approx)\n\
#float32 right_front_camera_yaw = -0.4974 # (approx -28.5 deg)\n\
#float32 right_front_camera_pitch = 0.0  # (assumed)\n\
#float32 right_front_camera_roll = 0.0   # (assumed)\n\
\n\
#float32 left_front_camera_px = 0.52     # velodyne_px+0.127 (approx)\n\
#float32 left_front_camera_py = 0.367    # velodyne_py+0.089 (approx)\n\
#float32 left_front_camera_pz = 2.184    # velodyne_pz-0.216 (approx)\n\
#float32 left_front_camera_yaw = 0.4974  # (approx +28.5 deg)\n\
#float32 left_front_camera_pitch = 0.0   # (assumed)\n\
#float32 left_front_camera_roll = 0.0    # (assumed)\n\
\n\
# Compute vehicle turning radius.  This is the distance from the\n\
# center of curvature to the vehicle origin in the middle of the\n\
# rear axle.  The <art/steering.h> comments describe the steering\n\
# geometry model.  Since max_steer_degrees is considerably less\n\
# than 90 degrees, there is no problem taking its tangent.\n\
\n\
float32 max_steer_degrees = 26.0        # maximum steering angle (degrees)\n\
float32 max_steer_radians = 0.4537856   # maximum steering angle (radians)\n\
\n\
# Due to limitations of the ROS message definition format, these\n\
# values needed to be calculated by hand...\n\
\n\
# ArtVehicle.wheelbase / math.tan(ArtVehicle.max_steer_radians)\n\
float32 turn_radius = 0.829067763\n\
\n\
# math.sqrt(math.pow(ArtVehicle.wheelbase,2)\n\
#           + math.pow(ArtVehicle.turn_radius + ArtVehicle.halfwidth,2))\n\
float32 front_outer_wheel_turn_radius = 1.510543171\n\
\n\
# math.sqrt(math.pow(ArtVehicle.wheelbase,2)\n\
#           + math.pow(ArtVehicle.turn_radius - ArtVehicle.halfwidth,2))\n\
float32 front_inner_wheel_turn_radius = 0.78096354\n\
\n\
# ArtVehicle.turn_radius + ArtVehicle.halfwidth\n\
float32 rear_outer_wheel_turn_radius = 1.049067763\n\
\n\
# ArtVehicle.turn_radius - ArtVehicle.halfwidth\n\
float32 rear_inner_wheel_turn_radius = 0.609067763\n\
\n\
# float32 front_outer_bumper_turn_radius = sqrtf(powf(front_bumper_px,2)+powf(turn_radius+halfwidth,2))\n\
#  \n\
# float32 front_inner_bumper_turn_radius = sqrtf(powf(front_bumper_px,2)+ powf(turn_radius-halfwidth,2))\n\
#\n\
# float32 rear_outer_bumper_turn_radius = sqrtf(powf(rear_bumper_px,2)+ powf(turn_radius+halfwidth,2))\n\
#\n\
# float32 rear_inner_bumper_turn_radius = sqrtf(powf(rear_bumper_px,2)+ powf(turn_radius-halfwidth,2))\n\
\n\
\n\
"; }
public:
  ROS_DEPRECATED static const std::string __s_getMessageDefinition() { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED const std::string __getMessageDefinition() const { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    ros::serialization::OStream stream(write_ptr, 1000000000);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    ros::serialization::IStream stream(read_ptr, 1000000000);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint32_t serializationLength() const
  {
    uint32_t size = 0;
    return size;
  }

  typedef boost::shared_ptr< ::wombot_msgs::WombotVehicle_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::wombot_msgs::WombotVehicle_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct WombotVehicle
typedef  ::wombot_msgs::WombotVehicle_<std::allocator<void> > WombotVehicle;

typedef boost::shared_ptr< ::wombot_msgs::WombotVehicle> WombotVehiclePtr;
typedef boost::shared_ptr< ::wombot_msgs::WombotVehicle const> WombotVehicleConstPtr;

template<typename ContainerAllocator> const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  WombotVehicle_<ContainerAllocator>::frame_id = "\"vehicle\"";
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::length = 0.55;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::width = 0.44;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::height = 0.3;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::halflength = 0.275;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::halfwidth = 0.22;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::halfheight = 0.15;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::wheelbase = 0.41;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::front_bumper_px = 0.47;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::rear_bumper_px = -0.08;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::front_left_wheel_px = 0.41;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::front_left_wheel_py = 0.22;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::front_right_wheel_px = 0.41;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::front_right_wheel_py = -0.22;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::rear_left_wheel_px = 0.0;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::rear_left_wheel_py = 0.22;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::rear_right_wheel_px = 0.0;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::rear_right_wheel_py = -0.22;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::geom_px = 0.195;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::geom_py = 0.0;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::geom_pa = 0.0;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::max_steer_degrees = 26.0;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::max_steer_radians = 0.4537856;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::turn_radius = 0.829067763;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::front_outer_wheel_turn_radius = 1.510543171;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::front_inner_wheel_turn_radius = 0.78096354;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::rear_outer_wheel_turn_radius = 1.049067763;
template<typename ContainerAllocator> const float WombotVehicle_<ContainerAllocator>::rear_inner_wheel_turn_radius = 0.609067763;

template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::wombot_msgs::WombotVehicle_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::wombot_msgs::WombotVehicle_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace wombot_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::wombot_msgs::WombotVehicle_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::wombot_msgs::WombotVehicle_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::wombot_msgs::WombotVehicle_<ContainerAllocator> > {
  static const char* value() 
  {
    return "c20c5cfb6e2f3e9f2e675c3f745ad041";
  }

  static const char* value(const  ::wombot_msgs::WombotVehicle_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xc20c5cfb6e2f3e9fULL;
  static const uint64_t static_value2 = 0x2e675c3f745ad041ULL;
};

template<class ContainerAllocator>
struct DataType< ::wombot_msgs::WombotVehicle_<ContainerAllocator> > {
  static const char* value() 
  {
    return "wombot_msgs/WombotVehicle";
  }

  static const char* value(const  ::wombot_msgs::WombotVehicle_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::wombot_msgs::WombotVehicle_<ContainerAllocator> > {
  static const char* value() 
  {
    return "#  ART vehicle dimensions.\n\
#  $Id: ArtVehicle.msg 1161 2011-03-26 02:10:49Z jack.oquin $\n\
\n\
#  This class encapsulates constants for the dimensions of the ART\n\
#  autonomous vehicle.  All units are meters or radians, except where\n\
#  noted.  This is not a published message, it defines multi-language\n\
#  constants.\n\
\n\
# ROS frame ID\n\
string frame_id = \"vehicle\"\n\
\n\
float32 length = 0.55                   # overall length\n\
float32 width = 0.44                    # overall width\n\
float32 height = 0.3                    # overall height (TBD)\n\
float32 halflength = 0.275                # length / 2\n\
float32 halfwidth = 0.22                # width / 2\n\
float32 halfheight = 0.15               # height / 2\n\
float32 wheelbase = 0.41     	# wheelbase\n\
\n\
# egocentric coordinates relative to vehicle origin at center of\n\
# rear axle\n\
float32 front_bumper_px = 0.47   	# (approximately)\n\
float32 rear_bumper_px = -0.08           # front_bumper_px - length\n\
float32 front_left_wheel_px = 0.41   # wheelbase\n\
float32 front_left_wheel_py = 0.22       # halfwidth\n\
float32 front_right_wheel_px = 0.41  # wheelbase\n\
float32 front_right_wheel_py = -0.22    #-halfwidth\n\
float32 rear_left_wheel_px = 0.0\n\
float32 rear_left_wheel_py = 0.22       # halfwidth\n\
float32 rear_right_wheel_px = 0.0\n\
float32 rear_right_wheel_py = -0.22     #-halfwidth\n\
\n\
# Player geometry, egocentric pose of robot base (the px really\n\
# does need to be positive for some reason)\n\
float32 geom_px = 0.195                   # front_bumper_px - halflength\n\
float32 geom_py = 0.0\n\
float32 geom_pa = 0.0\n\
\n\
#float32 velodyne_px = 0.393             # (approximately)\n\
#float32 velodyne_py = 0.278             # (approximately)\n\
#float32 velodyne_pz = 2.4               # (calibrated)\n\
#float32 velodyne_yaw=-0.0343           # (before remounting)\n\
#float32 velodyne_yaw=-0.02155           # (approximately)\n\
#float32 velodyne_pitch=0.016353735091186868 # (calculated)\n\
#float32 velodyne_roll=0.0062133721370998124 # (calculated)\n\
\n\
#float32 front_SICK_px = 3.178\n\
#float32 front_SICK_py= 0.0		# (approximately)\n\
#float32 front_SICK_pz = 0.941\n\
#float32 front_SICK_roll = 0.0		# (approximately)\n\
#float32 front_SICK_pitch = 0.0		# (approximately)\n\
#float32 front_SICK_yaw = 0.027	        # (approximately)\n\
\n\
#float32 rear_SICK_px = -1.140\n\
#float32 rear_SICK_py = 0.0              # (approximately)\n\
#float32 rear_SICK_pz = 0.943\n\
#float32 rear_SICK_roll = 0.0		# (approximately)\n\
#float32 rear_SICK_pitch = 0.0		# (approximately)\n\
#float32 rear_SICK_yaw = 3.1415926535897931160  # (approximately PI)\n\
\n\
#float32 right_front_camera_px = 0.52    # velodyne_px+0.127 (approx)\n\
#float32 right_front_camera_py = 0.189   # velodyne_py-0.089 (approx)\n\
#float32 right_front_camera_pz = 2.184   # velodyne_pz-0.216 (approx)\n\
#float32 right_front_camera_yaw = -0.4974 # (approx -28.5 deg)\n\
#float32 right_front_camera_pitch = 0.0  # (assumed)\n\
#float32 right_front_camera_roll = 0.0   # (assumed)\n\
\n\
#float32 left_front_camera_px = 0.52     # velodyne_px+0.127 (approx)\n\
#float32 left_front_camera_py = 0.367    # velodyne_py+0.089 (approx)\n\
#float32 left_front_camera_pz = 2.184    # velodyne_pz-0.216 (approx)\n\
#float32 left_front_camera_yaw = 0.4974  # (approx +28.5 deg)\n\
#float32 left_front_camera_pitch = 0.0   # (assumed)\n\
#float32 left_front_camera_roll = 0.0    # (assumed)\n\
\n\
# Compute vehicle turning radius.  This is the distance from the\n\
# center of curvature to the vehicle origin in the middle of the\n\
# rear axle.  The <art/steering.h> comments describe the steering\n\
# geometry model.  Since max_steer_degrees is considerably less\n\
# than 90 degrees, there is no problem taking its tangent.\n\
\n\
float32 max_steer_degrees = 26.0        # maximum steering angle (degrees)\n\
float32 max_steer_radians = 0.4537856   # maximum steering angle (radians)\n\
\n\
# Due to limitations of the ROS message definition format, these\n\
# values needed to be calculated by hand...\n\
\n\
# ArtVehicle.wheelbase / math.tan(ArtVehicle.max_steer_radians)\n\
float32 turn_radius = 0.829067763\n\
\n\
# math.sqrt(math.pow(ArtVehicle.wheelbase,2)\n\
#           + math.pow(ArtVehicle.turn_radius + ArtVehicle.halfwidth,2))\n\
float32 front_outer_wheel_turn_radius = 1.510543171\n\
\n\
# math.sqrt(math.pow(ArtVehicle.wheelbase,2)\n\
#           + math.pow(ArtVehicle.turn_radius - ArtVehicle.halfwidth,2))\n\
float32 front_inner_wheel_turn_radius = 0.78096354\n\
\n\
# ArtVehicle.turn_radius + ArtVehicle.halfwidth\n\
float32 rear_outer_wheel_turn_radius = 1.049067763\n\
\n\
# ArtVehicle.turn_radius - ArtVehicle.halfwidth\n\
float32 rear_inner_wheel_turn_radius = 0.609067763\n\
\n\
# float32 front_outer_bumper_turn_radius = sqrtf(powf(front_bumper_px,2)+powf(turn_radius+halfwidth,2))\n\
#  \n\
# float32 front_inner_bumper_turn_radius = sqrtf(powf(front_bumper_px,2)+ powf(turn_radius-halfwidth,2))\n\
#\n\
# float32 rear_outer_bumper_turn_radius = sqrtf(powf(rear_bumper_px,2)+ powf(turn_radius+halfwidth,2))\n\
#\n\
# float32 rear_inner_bumper_turn_radius = sqrtf(powf(rear_bumper_px,2)+ powf(turn_radius-halfwidth,2))\n\
\n\
\n\
";
  }

  static const char* value(const  ::wombot_msgs::WombotVehicle_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::wombot_msgs::WombotVehicle_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::wombot_msgs::WombotVehicle_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct WombotVehicle_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::wombot_msgs::WombotVehicle_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::wombot_msgs::WombotVehicle_<ContainerAllocator> & v) 
  {
  }
};


} // namespace message_operations
} // namespace ros

#endif // WOMBOT_MSGS_MESSAGE_WOMBOTVEHICLE_H

